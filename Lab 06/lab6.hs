{-# OPTIONS_GHC -fdefer-type-errors #-}
--Edgar Abundiz
-- lab6.hs
-- Number theory stuff
--

-- We'll use normal Integers for this lab, you don't need to worry about Nats.

-- The Euclidean division and remainder. As mentioned in class, these always
-- return a positive remainder. Use these when you need divison and modulo.
ediv :: Integer -> Integer -> Integer
ediv a b = let (q,r) = a `divMod` b 
           in if r < 0 then 
              if b > 0 then q-1 else q+1
              else q

emod :: Integer -> Integer -> Integer
emod a b = let r = a `mod` b 
           in if r < 0 then
              if b > 0 then r + b else r - b
              else r

-- Both combined
eDivMod :: Integer -> Integer -> (Integer,Integer)
eDivMod a b = (a `ediv` b, a `emod` b)

--------------------------------------------------------------------------------
-- Part 1

-- euclid a b
-- Returns the greatest common denominator of a and b, calculated via the
-- recursive Euclidean algorithm presented in class. DO NOT use the built-in
-- `gcd` function.
euclid :: Integer -> Integer -> Integer
euclid 0 0 = error "GCD(0,0) is undefined"
euclid a 0 = abs a
euclid 0 b = error "Can't divide by 0"
euclid a b = euclid b (a `emod` b)

-- lCM a b
-- Returns the least common multiple of a and b, using the definition of lcm
-- given in class (in terms of the gcd). DO NOT use the built-in `lcm` function.
lCM :: Integer -> Integer -> Integer
lCM 0 0 = error "LCM(0,0) is undefined"
lCM a b = (a*b) `ediv` euclid a b

-- extGCD a b
-- Returns the GCD of a and b, along with x and y such that
--   GCD(a,b) = ax + by
-- calculated via the recursive extended Euclidean algorithm presented in
-- class.
extGCD :: Integer -> Integer -> (Integer,Integer,Integer)
extGCD 0 0 = error "extGCD(0,0) is undefined"
extGCD a 0 = (a, 1, 0)     -- Base case
extGCD a b = let (q,r) = a `eDivMod` b           -- q and r of a/b
                 (c,x,y) = extGCD b(a `emod` b)            -- Recursive call
             in  (c, (y `emod` b), x-y * (a `ediv` b)) -- Recursive results

-- coprime a b 
-- Returns True if a and b are coprime (have no common factors)
coprime :: Integer -> Integer -> Bool
coprime 0 0 = error "coprime(0,0) is undefined"
coprime a b = euclid a b == 1

-- minv a n
-- Returns the modular inverse of a mod n. Assumes that a and n are coprime.
minv :: Integer -> Integer -> Integer
minv a n = let (c,x,y) = extGCD a n
                        in x
--------------------------------------------------------------------------------
-- Part 2: The Chinese Remainder Theorem

-- The (infinite) list of primes, generated by the Sieve of Eratosthenes.
-- We don't actually need this, but you might find it fun to play with.
primes :: [Integer]
primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x <- xs, rem x p /= 0]

-- pairwise_coprime as
-- Given a list of Integers, returns True if they are "pairwise coprime". I.e.,
-- if we can pick any two from the list and they will be coprime with each 
-- other. (We don't actually have to test every possible pair, because the
-- coprime relation is transitive: if coprime(a,b) and coprime(b,c), then we
-- implicitly know that coprime(a,c).) 
pairwise_coprime :: [Integer] -> Bool
pairwise_coprime [] = True
pairwise_coprime (a:as) = coprime_with a as && pairwise_coprime as
  where
    coprime_with a [] = True
    coprime_with a (b:bs) = coprime a b && coprime_with a bs



-- hideCrt n ms
-- Takes n (the secret) mod each m in ms, and returns the list of the as, each
-- paired with its respective ms. Each pair is a "key" to the secret, to be
-- distributed to one of the secret share-ers.
hideCrt :: Integer -> [Integer] ->[(Integer,Integer)]
hideCrt n ms = [(n `emod` a, a) | a <- ms]

-- revealCrt ams
-- Reveals the secret hidden in the list of keys-pairs ams. Each element of the
-- list is a pair (a,m), such that the secret, n = a mod m. We apply the 
-- CRT to the list to find n
revealCrt :: [(Integer,Integer)] -> Integer
revealCrt ams = let
    as = map fst ams  -- The list of as
    ms = map snd ams  -- The list of ms

    -- Here's where your part begins:
    mm = product ms   -- M, product of the ms
    mds = [mm `ediv` m | m <- ms]    -- mds, M divided by each m in ms, 
    mdis = [minv x y | (x,y) <- zip mds ms ]  -- mdis, the modular inverse of each mds, mod its ms
    sol = sum [x * y * z | (x,y,z) <- zip3 as mds mdis]  -- The solution, the sum of each (a * md * mdi)
  in
    sol `emod` mm     -- Reduce the solution mod M



-- Example:
-- We want to distribute the secret `1337` to three people. We choose
-- three coprime values such that their product is > 1337. In this case, we
-- choose 111,  

